# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost(
    "The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc."
    weight: String!
) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The purpose of the `@listSize` directive is to either inform the static analysis about the size of returned lists (if that information is statically available), or to point the analysis to where to find that information."
directive @listSize(
    "The `assumedSize` argument can be used to statically define the maximum length of a list returned by a field."
    assumedSize: Int,
    "The `requireOneSlicingArgument` argument can be used to inform the static analysis that it should expect that exactly one of the defined slicing arguments is present in a query. If that is not the case (i.e., if none or multiple slicing arguments are present), the static analysis may throw an error."
    requireOneSlicingArgument: Boolean! = true,
    "The `sizedFields` argument can be used to define that the value of the `assumedSize` argument or of a slicing argument does not affect the size of a list returned by a field itself, but that of a list returned by one of its sub-fields."
    sizedFields: [String!],
    "The `slicingArgumentDefaultValue` argument can be used to define a default value for a slicing argument, which is used if the argument is not present in a query."
    slicingArgumentDefaultValue: Int,
    "The `slicingArguments` argument can be used to define which of the field's arguments with numeric type are slicing arguments, so that their value determines the size of the list returned by that field. It may specify a list of multiple slicing arguments."
    slicingArguments: [String!]
) on FIELD_DEFINITION

interface Notification {
    createdAt: DateTime!
    discriminator: String!
    id: UUID!
    seen: Boolean!
}

type BanUserResponse {
    id: UUID!
}

type BannedUserDto {
    bannedAt: DateTime!
    bannedBy: StreamerDto
    bannedById: String!
    bannedUntil: DateTime!
    id: UUID!
    reason: String!
    user: StreamerDto
    userId: String!
}

"A connection to a list of items."
type BannedUsersConnection {
    "A list of edges."
    edges: [BannedUsersEdge!]
    "A flattened list of the nodes."
    nodes: [BannedUserDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type BannedUsersEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: BannedUserDto!
}

type BannerDto {
    description: String
    id: UUID!
    image: String
    title: String
    url: String
}

"A connection to a list of items."
type CategoriesConnection {
    "A list of edges."
    edges: [CategoriesEdge!]
    "A flattened list of the nodes."
    nodes: [CategoryDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type CategoriesEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: CategoryDto!
}

type CategoryDto {
    id: UUID!
    image: String!
    slug: String!
    title: String!
    watchers: Long!
}

type ChatDto {
    id: UUID!
    pinnedMessage: PinnedChatMessageDto
    pinnedMessageId: UUID
    settings: ChatSettingsDto
    settingsId: UUID!
    streamerId: String!
}

type ChatMessageDto {
    createdAt: DateTime!
    id: UUID!
    isActive: Boolean!
    isDeleted: Boolean!
    message: String!
    reply: ChatMessageDto
    replyId: UUID
    sender: StreamerDto
    senderId: String!
    type: ChatMessageType!
}

"A connection to a list of items."
type ChatMessagesConnection {
    "A list of edges."
    edges: [ChatMessagesEdge!]
    "A flattened list of the nodes."
    nodes: [ChatMessageDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ChatMessagesEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ChatMessageDto!
}

type ChatSettingsDto {
    bannedWords: [String!]!
    followersOnly: Boolean!
    id: UUID!
    slowMode: Int
    subscribersOnly: Boolean!
}

type CreateBannerResponse {
    id: UUID!
}

type CreateCategoryResponse {
    id: UUID!
}

type CreateMessageResponse {
    messageId: UUID!
}

type CreateRoleResponse {
    id: UUID!
}

type DeleteMessageResponse {
    id: UUID!
}

type EditCategoryResponse {
    id: UUID!
}

type EditNotificationSettingsResponse {
    id: UUID!
}

type EditRoleResponse {
    id: UUID!
}

type EditVodSettingsResponse {
    id: UUID!
}

type FinishAuthResponse {
    id: String!
}

type FollowResponse {
    id: UUID!
}

type GetEmailResponse {
    email: String!
}

type LiveStartedNotificationDto implements Notification {
    createdAt: DateTime!
    discriminator: String!
    id: UUID!
    seen: Boolean!
    streamer: StreamerDto
    streamerId: String!
}

type Mutation {
    banUser(request: BanUserInput!): BanUserResponse!
    createBanner(banner: CreateBannerInput!): CreateBannerResponse!
    createCategory(input: CreateCategoryInput!): CreateCategoryResponse!
    createMessage(request: CreateMessageInput!): CreateMessageResponse!
    createRole(input: CreateRoleInput!): CreateRoleResponse!
    deleteMessage(request: DeleteMessageInput!): DeleteMessageResponse!
    editNotificationSettings(readNotification: EditNotificationSettingsInput!): EditNotificationSettingsResponse!
    editRole(input: EditRoleInput!): EditRoleResponse!
    editVodSettings(request: EditVodSettingsInput!): EditVodSettingsResponse!
    finishAuth(input: FinishAuthInput!): FinishAuthResponse!
    follow(follow: FollowInput!): FollowResponse!
    pinMessage(pinMessage: PinMessageInput!): PinMessageResponse!
    readAllNotifications: ReadAllNotificationsResponse!
    readNotification(readNotification: ReadNotificationInput!): ReadNotificationResponse!
    removeBanner(banner: RemoveBannerInput!): RemoveBannerResponse!
    removeCategory(input: RemoveCategoryInput!): RemoveCategoryResponse!
    removeRole(input: RemoveRoleInput!): RemoveRoleResponse!
    removeVod(request: RemoveVodInput!): RemoveVodResponse!
    unbanUser(request: UnbanUserInput!): UnbanUserResponse!
    unfollow(unfollow: UnfollowInput!): UnfollowResponse!
    unpinMessage(request: UnpinMessageInput!): UnpinMessageResponse!
    updateAvatar(input: UpdateAvatarInput!): UpdateAvatarResponse!
    updateBanner(banner: UpdateBannerInput!): UpdateBannerResponse!
    updateBio(input: UpdateBioInput!): UpdateBioResponse!
    updateCategory(input: EditCategoryInput!): EditCategoryResponse!
    updateChannelBanner(input: UpdateChannelBannerInput!): UpdateChannelBannerResponse!
    updateChatSettings(request: UpdateChatSettingsInput!): UpdateChatSettingsResponse!
    updateOfflineBanner(input: UpdateOfflineBannerInput!): UpdateOfflineBannerResponse!
    updateProfile(input: UpdateProfileInput!): UpdateProfileResponse!
    updateStreamInfo(streamInfo: UpdateStreamInfoInput!): UpdateStreamInfoResponse!
    updateStreamSettings: UpdateStreamSettingsResponse!
    updateVod(request: UpdateVodInput!): UpdateVodResponse!
    upload(input: UploadFileInput!): UploadFileResponse!
}

"A connection to a list of items."
type MyFollowingsConnection {
    "A list of edges."
    edges: [MyFollowingsEdge!]
    "A flattened list of the nodes."
    nodes: [StreamerFollowerDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type MyFollowingsEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: StreamerFollowerDto!
}

"A connection to a list of items."
type MyRolesConnection {
    "A list of edges."
    edges: [MyRolesEdge!]
    "A flattened list of the nodes."
    nodes: [RoleDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type MyRolesEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: RoleDto!
}

type NotificationSettingsDto {
    id: UUID!
    streamerLive: Boolean!
    userFollowed: Boolean!
}

"A connection to a list of items."
type NotificationsConnection {
    "A list of edges."
    edges: [NotificationsEdge!]
    "A flattened list of the nodes."
    nodes: [Notification!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type NotificationsEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Notification!
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "Indicates whether more edges exist following the set defined by the clients arguments."
    hasNextPage: Boolean!
    "Indicates whether more edges exist prior the set defined by the clients arguments."
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type PermissionsFlags {
    isAll: Boolean!
    isBanners: Boolean!
    isChat: Boolean!
    isNone: Boolean!
    isRoles: Boolean!
    isStream: Boolean!
    isVod: Boolean!
}

type PinMessageResponse {
    id: UUID!
}

type PinnedChatMessageDto {
    createdAt: DateTime!
    id: UUID!
    message: ChatMessageDto
    messageId: UUID!
    pinnedBy: StreamerDto
    pinnedById: String!
}

type ProfileDto {
    bio: String
    channelBanner: String
    discord: String
    instagram: String
    offlineStreamBanner: String
    streamer: StreamerDto
    streamerId: String!
    youtube: String
}

type Query {
    bannedUsers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [BannedUserDtoSortInput!],
        streamerId: String!,
        where: BannedUserDtoFilterInput
    ): BannedUsersConnection
    banners(streamerId: String!): [BannerDto!]!
    categories(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [CategoryDtoSortInput!],
        search: String,
        tag: UUID,
        where: CategoryDtoFilterInput
    ): CategoriesConnection
    category(id: UUID!): CategoryDto!
    categoryBySlug(slug: String!): CategoryDto!
    chat(streamerId: String!): ChatDto!
    chatMessages(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        chatId: UUID!,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [ChatMessageDtoSortInput!],
        where: ChatMessageDtoFilterInput
    ): ChatMessagesConnection
    chatMessagesHistory(chatId: UUID!, order: [ChatMessageDtoSortInput!], startFrom: DateTime!, where: ChatMessageDtoFilterInput): [ChatMessageDto!]!
    chatSettings: ChatSettingsDto!
    currentStream(streamerId: String!): StreamDto!
    me: StreamerMeDto!
    myEmail: GetEmailResponse!
    myFollowings(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [StreamerFollowerDtoSortInput!],
        search: String,
        where: StreamerFollowerDtoFilterInput
    ): MyFollowingsConnection
    myRole(broadcasterId: String!): RoleDto!
    myRoles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [RoleDtoSortInput!],
        where: RoleDtoFilterInput
    ): MyRolesConnection
    mySystemRole: SystemRoleDto!
    notificationSettings: NotificationSettingsDto!
    notifications(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int
    ): NotificationsConnection
    profile(streamerId: String!): ProfileDto!
    role(id: UUID!): RoleDto!
    roles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        broadcasterId: String!,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [RoleDtoSortInput!],
        roleType: RoleType!,
        where: RoleDtoFilterInput
    ): RolesConnection
    search(search: String!): [SearchResult!]!
    streamInfo(streamerId: String!): StreamInfoDto!
    streamSettings: StreamSettingsDto!
    streamer(userName: String!): StreamerDto!
    streamerInteraction(streamerId: String!): StreamerInteractionDto!
    streamers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [StreamerDtoSortInput!],
        search: String,
        where: StreamerDtoFilterInput
    ): StreamersConnection
    streams(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        categoryId: UUID,
        "Returns the first _n_ elements from the list."
        first: Int,
        languages: [String!],
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [StreamDtoSortInput!],
        tag: UUID,
        where: StreamDtoFilterInput
    ): StreamsConnection
    tags(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [TagDtoSortInput!],
        where: TagDtoFilterInput
    ): TagsConnection
    topCategories: [CategoryDto!]!
    topStreams: [StreamDto!]!
    vod(vodId: UUID!): VodDto!
    vodSettings: VodSettingsDto!
    vods(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [VodDtoSortInput!],
        streamerId: String!,
        where: VodDtoFilterInput
    ): VodsConnection
}

type ReadAllNotificationsResponse {
    result: Boolean!
}

type ReadNotificationResponse {
    hasUnreadNotifications: Boolean!
}

type RemoveBannerResponse {
    id: UUID!
}

type RemoveCategoryResponse {
    id: UUID!
}

type RemoveRoleResponse {
    id: UUID!
}

type RemoveVodResponse {
    id: UUID!
}

type RoleDto {
    broadcaster: StreamerDto
    broadcasterId: String!
    id: UUID!
    permissions: PermissionsFlags!
    streamer: StreamerDto
    streamerId: String!
    type: RoleType!
}

"A connection to a list of items."
type RolesConnection {
    "A list of edges."
    edges: [RolesEdge!]
    "A flattened list of the nodes."
    nodes: [RoleDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type RolesEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: RoleDto!
}

type SearchResult {
    image: String
    resultType: SearchResultType!
    slug: String!
    title: String!
}

type StreamDto {
    active: Boolean!
    category: CategoryDto
    categoryId: UUID
    currentViewers: Long!
    id: UUID!
    language: String!
    preview: String
    sources: [StreamSourceDto!]!
    started: DateTime!
    streamer: StreamerDto
    streamerId: String!
    tags: [TagDto!]!
    title: String!
}

type StreamInfoDto {
    category: CategoryDto
    categoryId: UUID
    id: UUID!
    language: String!
    streamerId: String!
    tags: [TagDto!]!
    title: String
}

type StreamSettingsDto {
    id: UUID!
    streamKey: String!
    streamUrl: String!
}

type StreamSourceDto {
    sourceType: StreamSourceType!
    streamId: UUID!
    url: String!
}

type StreamWatcher {
    streamId: UUID!
}

type StreamerDto {
    avatar: String
    followers: Long!
    id: String!
    isLive: Boolean!
    userName: String
}

type StreamerFollowerDto {
    avatar: String
    currentStream: StreamDto
    currentStreamId: UUID
    id: String!
    isLive: Boolean!
    userName: String
}

type StreamerInteractionDto {
    banned: Boolean!
    bannedUntil: DateTime
    followed: Boolean!
    followedAt: DateTime
    lastTimeMessage: DateTime
    permissions: PermissionsFlags!
}

type StreamerMeDto {
    avatar: String
    finishedAuth: Boolean!
    followers: Long!
    hasUnreadNotifications: Boolean!
    id: String!
    isLive: Boolean!
    userName: String
}

"A connection to a list of items."
type StreamersConnection {
    "A list of edges."
    edges: [StreamersEdge!]
    "A flattened list of the nodes."
    nodes: [StreamerDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type StreamersEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: StreamerDto!
}

"A connection to a list of items."
type StreamsConnection {
    "A list of edges."
    edges: [StreamsEdge!]
    "A flattened list of the nodes."
    nodes: [StreamDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type StreamsEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: StreamDto!
}

type Subscription {
    chatMessageCreated(chatId: UUID!): ChatMessageDto!
    chatMessageDeleted(chatId: UUID!): ChatMessageDto!
    chatUpdated(chatId: UUID!): ChatDto!
    notificationCreated: Notification!
    streamUpdated(streamId: UUID!): StreamDto!
    streamerUpdated(streamerId: String!): StreamerDto!
    subscribeNotificationCreated: [Notification!]!
    subscribeWatchStream(streamId: UUID!): [StreamWatcher!]!
    userBanned(broadcasterId: String!, userId: String!): BannedUserDto!
    userUnbanned(broadcasterId: String!, userId: String!): BannedUserDto!
    watchStream(streamId: UUID!): StreamWatcher!
}

type SystemRoleDto {
    roleType: SystemRoleType!
    streamer: StreamerDto
    streamerId: String!
}

type TagDto {
    id: UUID!
    title: String!
}

"A connection to a list of items."
type TagsConnection {
    "A list of edges."
    edges: [TagsEdge!]
    "A flattened list of the nodes."
    nodes: [TagDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type TagsEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: TagDto!
}

type UnbanUserResponse {
    id: UUID!
}

type UnfollowResponse {
    id: UUID!
}

type UnpinMessageResponse {
    messageId: UUID!
}

type UpdateAvatarResponse {
    file: String!
}

type UpdateBannerResponse {
    id: UUID!
}

type UpdateBioResponse {
    id: UUID!
}

type UpdateChannelBannerResponse {
    id: UUID!
}

type UpdateChatSettingsResponse {
    id: UUID!
}

type UpdateOfflineBannerResponse {
    id: UUID!
}

type UpdateProfileResponse {
    id: UUID!
}

type UpdateStreamInfoResponse {
    id: UUID!
}

type UpdateStreamSettingsResponse {
    id: UUID!
}

type UpdateVodResponse {
    id: UUID!
}

type UploadFileResponse {
    fileName: String!
}

type VodDto {
    category: CategoryDto
    categoryId: UUID
    createdAt: DateTime!
    description: String
    duration: Long!
    id: UUID!
    language: String!
    preview: String
    source: String
    streamer: StreamerDto
    streamerId: String!
    tags: [TagDto!]!
    title: String
    type: VodType!
    views: Long!
}

type VodSettingsDto {
    id: UUID!
    vodEnabled: Boolean!
}

"A connection to a list of items."
type VodsConnection {
    "A list of edges."
    edges: [VodsEdge!]
    "A flattened list of the nodes."
    nodes: [VodDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type VodsEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: VodDto!
}

"Defines when a policy shall be executed."
enum ApplyPolicy {
    "After the resolver was executed."
    AFTER_RESOLVER
    "Before the resolver was executed."
    BEFORE_RESOLVER
    "The policy is applied in the validation step before the execution."
    VALIDATION
}

enum ChatMessageType {
    USER_MESSAGE
}

enum RoleType {
    ADMINISTRATOR
    BROADCASTER
}

enum SearchResultType {
    CATEGORY
    STREAMER
}

enum SortEnumType {
    ASC
    DESC
}

enum StreamSourceType {
    HLS
    WEB_RTC
}

enum SystemRoleType {
    ADMINISTRATOR
}

enum VodType {
    PRIVATE
    PUBLIC
}

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

scalar UUID

"The `Upload` scalar type represents a file upload."
scalar Upload

input BanUserInput {
    banUntil: DateTime!
    broadcasterId: String!
    reason: String!
    userId: String!
}

input BannedUserDtoFilterInput {
    and: [BannedUserDtoFilterInput!]
    bannedAt: DateTimeOperationFilterInput
    bannedById: StringOperationFilterInput
    bannedUntil: DateTimeOperationFilterInput
    id: UuidOperationFilterInput
    or: [BannedUserDtoFilterInput!]
    reason: StringOperationFilterInput
    userId: StringOperationFilterInput
}

input BannedUserDtoSortInput {
    bannedAt: SortEnumType
    bannedById: SortEnumType
    bannedUntil: SortEnumType
    id: SortEnumType
    reason: SortEnumType
    userId: SortEnumType
}

input BooleanOperationFilterInput {
    eq: Boolean
    neq: Boolean
}

input CategoryDtoFilterInput {
    and: [CategoryDtoFilterInput!]
    id: UuidOperationFilterInput
    image: StringOperationFilterInput
    or: [CategoryDtoFilterInput!]
    slug: StringOperationFilterInput
    title: StringOperationFilterInput
}

input CategoryDtoSortInput {
    id: SortEnumType
    image: SortEnumType
    slug: SortEnumType
    title: SortEnumType
}

input ChatMessageDtoFilterInput {
    and: [ChatMessageDtoFilterInput!]
    createdAt: DateTimeOperationFilterInput
    id: UuidOperationFilterInput
    isActive: BooleanOperationFilterInput
    isDeleted: BooleanOperationFilterInput
    message: StringOperationFilterInput
    or: [ChatMessageDtoFilterInput!]
    replyId: UuidOperationFilterInput
    senderId: StringOperationFilterInput
    type: ChatMessageTypeOperationFilterInput
}

input ChatMessageDtoSortInput {
    createdAt: SortEnumType
    id: SortEnumType
    isActive: SortEnumType
    isDeleted: SortEnumType
    message: SortEnumType
    replyId: SortEnumType
    senderId: SortEnumType
    type: SortEnumType
}

input ChatMessageTypeOperationFilterInput {
    eq: ChatMessageType
    in: [ChatMessageType!]
    neq: ChatMessageType
    nin: [ChatMessageType!]
}

input CreateBannerInput {
    description: String
    image: String
    streamerId: String!
    title: String
    url: String
}

input CreateCategoryInput {
    image: String!
    title: String!
}

input CreateMessageInput {
    chatId: UUID!
    message: String!
    replyMessageId: UUID
}

input CreateRoleInput {
    broadcasterId: String!
    permissions: PermissionsFlagsInput!
    roleType: RoleType!
    streamerId: String!
}

input DateTimeOperationFilterInput {
    eq: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime]
    lt: DateTime
    lte: DateTime
    neq: DateTime
    ngt: DateTime
    ngte: DateTime
    nin: [DateTime]
    nlt: DateTime
    nlte: DateTime
}

input DeleteMessageInput {
    messageId: UUID!
}

input EditCategoryInput {
    id: UUID!
    image: String!
    title: String!
}

input EditNotificationSettingsInput {
    streamerLive: Boolean!
    userFollowed: Boolean!
}

input EditRoleInput {
    permissions: PermissionsFlagsInput!
    roleId: UUID!
}

input EditVodSettingsInput {
    vodEnabled: Boolean!
}

input FinishAuthInput {
    userName: String!
}

input FollowInput {
    streamerId: String!
}

input LongOperationFilterInput {
    eq: Long
    gt: Long
    gte: Long
    in: [Long]
    lt: Long
    lte: Long
    neq: Long
    ngt: Long
    ngte: Long
    nin: [Long]
    nlt: Long
    nlte: Long
}

input PermissionsFlagsInput {
    isAll: Boolean
    isBanners: Boolean
    isChat: Boolean
    isNone: Boolean
    isRoles: Boolean
    isStream: Boolean
    isVod: Boolean
}

input PermissionsOperationFilterInput {
    eq: PermissionsFlagsInput
    in: [PermissionsFlagsInput!]
    neq: PermissionsFlagsInput
    nin: [PermissionsFlagsInput!]
}

input PinMessageInput {
    messageId: UUID!
}

input ReadNotificationInput {
    id: UUID!
}

input RemoveBannerInput {
    bannerId: UUID!
    streamerId: String!
}

input RemoveCategoryInput {
    id: UUID!
}

input RemoveRoleInput {
    roleId: UUID!
}

input RemoveVodInput {
    id: UUID!
}

input RoleDtoFilterInput {
    and: [RoleDtoFilterInput!]
    broadcasterId: StringOperationFilterInput
    id: UuidOperationFilterInput
    or: [RoleDtoFilterInput!]
    permissions: PermissionsOperationFilterInput
    streamerId: StringOperationFilterInput
    type: RoleTypeOperationFilterInput
}

input RoleDtoSortInput {
    broadcasterId: SortEnumType
    id: SortEnumType
    permissions: SortEnumType
    streamerId: SortEnumType
    type: SortEnumType
}

input RoleTypeOperationFilterInput {
    eq: RoleType
    in: [RoleType!]
    neq: RoleType
    nin: [RoleType!]
}

input StreamDtoFilterInput {
    active: BooleanOperationFilterInput
    and: [StreamDtoFilterInput!]
    categoryId: UuidOperationFilterInput
    currentViewers: LongOperationFilterInput
    id: UuidOperationFilterInput
    language: StringOperationFilterInput
    or: [StreamDtoFilterInput!]
    preview: StringOperationFilterInput
    started: DateTimeOperationFilterInput
    streamerId: StringOperationFilterInput
    title: StringOperationFilterInput
}

input StreamDtoSortInput {
    active: SortEnumType
    categoryId: SortEnumType
    currentViewers: SortEnumType
    id: SortEnumType
    language: SortEnumType
    preview: SortEnumType
    started: SortEnumType
    streamerId: SortEnumType
    title: SortEnumType
}

input StreamerDtoFilterInput {
    and: [StreamerDtoFilterInput!]
    avatar: StringOperationFilterInput
    followers: LongOperationFilterInput
    id: StringOperationFilterInput
    isLive: BooleanOperationFilterInput
    or: [StreamerDtoFilterInput!]
    userName: StringOperationFilterInput
}

input StreamerDtoSortInput {
    avatar: SortEnumType
    followers: SortEnumType
    id: SortEnumType
    isLive: SortEnumType
    userName: SortEnumType
}

input StreamerFollowerDtoFilterInput {
    and: [StreamerFollowerDtoFilterInput!]
    avatar: StringOperationFilterInput
    currentStreamId: UuidOperationFilterInput
    id: StringOperationFilterInput
    isLive: BooleanOperationFilterInput
    or: [StreamerFollowerDtoFilterInput!]
    userName: StringOperationFilterInput
}

input StreamerFollowerDtoSortInput {
    avatar: SortEnumType
    currentStreamId: SortEnumType
    id: SortEnumType
    isLive: SortEnumType
    userName: SortEnumType
}

input StringOperationFilterInput {
    and: [StringOperationFilterInput!]
    contains: String
    endsWith: String
    eq: String
    in: [String]
    ncontains: String
    nendsWith: String
    neq: String
    nin: [String]
    nstartsWith: String
    or: [StringOperationFilterInput!]
    startsWith: String
}

input TagDtoFilterInput {
    and: [TagDtoFilterInput!]
    id: UuidOperationFilterInput
    or: [TagDtoFilterInput!]
    title: StringOperationFilterInput
}

input TagDtoSortInput {
    id: SortEnumType
    title: SortEnumType
}

input UnbanUserInput {
    broadcasterId: String!
    userId: String!
}

input UnfollowInput {
    streamerId: String!
}

input UnpinMessageInput {
    chatId: UUID!
}

input UpdateAvatarInput {
    file: String!
}

input UpdateBannerInput {
    bannerId: UUID!
    description: String
    image: String
    streamerId: String!
    title: String
    url: String
}

input UpdateBioInput {
    bio: String!
}

input UpdateChannelBannerInput {
    channelBanner: String!
}

input UpdateChatSettingsInput {
    bannedWords: [String!]!
    followersOnly: Boolean!
    id: UUID!
    slowMode: Int
    subscribersOnly: Boolean!
}

input UpdateOfflineBannerInput {
    offlineBanner: String!
}

input UpdateProfileInput {
    discord: String
    instagram: String
    youtube: String
}

input UpdateStreamInfoInput {
    categoryId: UUID
    language: String!
    streamerId: String!
    tags: [String!]!
    title: String!
}

input UpdateVodInput {
    categoryId: UUID
    description: String!
    id: UUID!
    language: String!
    tags: [String!]!
    title: String!
    type: VodType!
}

input UploadFileInput {
    file: Upload!
}

input UuidOperationFilterInput {
    eq: UUID
    gt: UUID
    gte: UUID
    in: [UUID]
    lt: UUID
    lte: UUID
    neq: UUID
    ngt: UUID
    ngte: UUID
    nin: [UUID]
    nlt: UUID
    nlte: UUID
}

input VodDtoFilterInput {
    and: [VodDtoFilterInput!]
    categoryId: UuidOperationFilterInput
    createdAt: DateTimeOperationFilterInput
    description: StringOperationFilterInput
    duration: LongOperationFilterInput
    id: UuidOperationFilterInput
    language: StringOperationFilterInput
    or: [VodDtoFilterInput!]
    preview: StringOperationFilterInput
    source: StringOperationFilterInput
    streamerId: StringOperationFilterInput
    title: StringOperationFilterInput
    type: VodTypeOperationFilterInput
    views: LongOperationFilterInput
}

input VodDtoSortInput {
    categoryId: SortEnumType
    createdAt: SortEnumType
    description: SortEnumType
    duration: SortEnumType
    id: SortEnumType
    language: SortEnumType
    preview: SortEnumType
    source: SortEnumType
    streamerId: SortEnumType
    title: SortEnumType
    type: SortEnumType
    views: SortEnumType
}

input VodTypeOperationFilterInput {
    eq: VodType
    in: [VodType!]
    neq: VodType
    nin: [VodType!]
}
