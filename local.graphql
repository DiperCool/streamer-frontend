# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost(
    "The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc."
    weight: String!
) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The purpose of the `@listSize` directive is to either inform the static analysis about the size of returned lists (if that information is statically available), or to point the analysis to where to find that information."
directive @listSize(
    "The `assumedSize` argument can be used to statically define the maximum length of a list returned by a field."
    assumedSize: Int,
    "The `requireOneSlicingArgument` argument can be used to inform the static analysis that it should expect that exactly one of the defined slicing arguments is present in a query. If that is not the case (i.e., if none or multiple slicing arguments are present), the static analysis may throw an error."
    requireOneSlicingArgument: Boolean! = true,
    "The `sizedFields` argument can be used to define that the value of the `assumedSize` argument or of a slicing argument does not affect the size of a list returned by a field itself, but that of a list returned by one of its sub-fields."
    sizedFields: [String!],
    "The `slicingArgumentDefaultValue` argument can be used to define a default value for a slicing argument, which is used if the argument is not present in a query."
    slicingArgumentDefaultValue: Int,
    "The `slicingArguments` argument can be used to define which of the field's arguments with numeric type are slicing arguments, so that their value determines the size of the list returned by that field. It may specify a list of multiple slicing arguments."
    slicingArguments: [String!]
) on FIELD_DEFINITION

type ChatDto {
    id: UUID!
    pinnedMessage: PinnedChatMessageDto
    pinnedMessageId: UUID
    settings: ChatSettingsDto
    settingsId: UUID!
    streamerId: String!
}

type ChatMessageDto {
    createdAt: DateTime!
    id: UUID!
    isActive: Boolean!
    isDeleted: Boolean!
    message: String!
    reply: ChatMessageDto
    replyId: UUID
    sender: StreamerDto
    senderId: String!
    type: ChatMessageType!
}

"A connection to a list of items."
type ChatMessagesConnection {
    "A list of edges."
    edges: [ChatMessagesEdge!]
    "A flattened list of the nodes."
    nodes: [ChatMessageDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ChatMessagesEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ChatMessageDto!
}

type ChatSettingsDto {
    bannedWords: [String!]!
    followersOnly: Boolean!
    id: UUID!
    slowMode: Int
    subscribersOnly: Boolean!
}

type CreateMessageResponse {
    messageId: UUID!
}

type CreateRoleResponse {
    id: UUID!
}

type DeleteMessageResponse {
    id: UUID!
}

type FinishAuthResponse {
    id: String!
}

type FollowResponse {
    id: UUID!
}

type GetEmailResponse {
    email: String!
}

type Mutation {
    createMessage(request: CreateMessageInput!): CreateMessageResponse!
    createRole(input: CreateRoleInput!): CreateRoleResponse!
    deleteMessage(request: DeleteMessageInput!): DeleteMessageResponse!
    finishAuth(input: FinishAuthInput!): FinishAuthResponse!
    follow(follow: FollowInput!): FollowResponse!
    pinMessage(pinMessage: PinMessageInput!): PinMessageResponse!
    removeRole(input: RemoveRoleInput!): RemoveRoleResponse!
    unfollow(unfollow: UnfollowInput!): UnfollowResponse!
    unpinMessage(request: UnpinMessageInput!): UnpinMessageResponse!
    updateAvatar(input: UpdateAvatarInput!): UpdateAvatarResponse!
    updateBio(input: UpdateBioInput!): UpdateBioResponse!
    updateChannelBanner(input: UpdateChannelBannerInput!): UpdateChannelBannerResponse!
    updateChatSettings(request: UpdateChatSettingsInput!): UpdateChatSettingsResponse!
    updateOfflineBanner(input: UpdateOfflineBannerInput!): UpdateOfflineBannerResponse!
    updateProfile(input: UpdateProfileInput!): UpdateProfileResponse!
    updateStreamSettings: UpdateStreamSettingsResponse!
    upload(input: UploadFileInput!): UploadFileResponse!
}

"A connection to a list of items."
type MyRolesConnection {
    "A list of edges."
    edges: [MyRolesEdge!]
    "A flattened list of the nodes."
    nodes: [RoleDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type MyRolesEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: RoleDto!
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "Indicates whether more edges exist following the set defined by the clients arguments."
    hasNextPage: Boolean!
    "Indicates whether more edges exist prior the set defined by the clients arguments."
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type PinMessageResponse {
    id: UUID!
}

type PinnedChatMessageDto {
    createdAt: DateTime!
    id: UUID!
    message: ChatMessageDto
    messageId: UUID!
    pinnedBy: StreamerDto
    pinnedById: String!
}

type ProfileDto {
    bio: String
    channelBanner: String
    discord: String
    instagram: String
    offlineStreamBanner: String
    streamer: StreamerDto
    streamerId: String!
    youtube: String
}

type Query {
    chat(streamerId: String!): ChatDto!
    chatMessages(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        chatId: UUID!,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [ChatMessageDtoSortInput!],
        where: ChatMessageDtoFilterInput
    ): ChatMessagesConnection
    chatMessagesHistory(chatId: UUID!, order: [ChatMessageDtoSortInput!], startFrom: DateTime!, where: ChatMessageDtoFilterInput): [ChatMessageDto!]!
    chatSettings: ChatSettingsDto!
    currentStream(streamerId: String!): StreamDto!
    me: StreamerMeDto!
    myEmail: GetEmailResponse!
    myRoles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [RoleDtoSortInput!],
        where: RoleDtoFilterInput
    ): MyRolesConnection
    profile(streamerId: String!): ProfileDto!
    roles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        broadcasterId: String!,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [RoleDtoSortInput!],
        roleType: RoleType!,
        where: RoleDtoFilterInput
    ): RolesConnection
    streamSettings: StreamSettingsDto!
    streamer(userName: String!): StreamerDto!
    streamerInteraction(streamerId: String!): StreamerInteractionDto!
    vod(vodId: UUID!): VodDto!
    vods(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [VodDtoSortInput!],
        streamerId: String!,
        where: VodDtoFilterInput
    ): VodsConnection
}

type RemoveRoleResponse {
    id: UUID!
}

type RoleDto {
    broadcaster: StreamerDto
    broadcasterId: String!
    id: UUID!
    streamer: StreamerDto
    streamerId: String!
    type: RoleType!
}

"A connection to a list of items."
type RolesConnection {
    "A list of edges."
    edges: [RolesEdge!]
    "A flattened list of the nodes."
    nodes: [RoleDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type RolesEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: RoleDto!
}

type StreamDto {
    active: Boolean!
    currentViewers: Long!
    id: UUID!
    sources: [StreamSourceDto!]!
    streamer: StreamerDto
    streamerId: String!
    title: String!
}

type StreamSettingsDto {
    id: UUID!
    streamKey: String!
    streamUrl: String!
}

type StreamSourceDto {
    sourceType: StreamSourceType!
    streamId: UUID!
    url: String!
}

type StreamWatcher {
    streamId: UUID!
}

type StreamerDto {
    avatar: String
    followers: Long!
    id: String!
    isLive: Boolean!
    userName: String
}

type StreamerInteractionDto {
    followed: Boolean!
    followedAt: DateTime
}

type StreamerMeDto {
    avatar: String
    finishedAuth: Boolean!
    followers: Long!
    id: String!
    isLive: Boolean!
    userName: String
}

type Subscription {
    chatMessageCreated(chatId: UUID!): ChatMessageDto!
    chatMessageDeleted(chatId: UUID!): ChatMessageDto!
    chatUpdated(chatId: UUID!): ChatDto!
    streamUpdated(streamId: UUID!): StreamDto!
    streamerUpdated(streamerId: String!): StreamerDto!
    subscribeWatchStream(streamId: UUID!): [StreamWatcher!]!
    watchStream(streamId: UUID!): StreamWatcher!
}

type UnfollowResponse {
    id: UUID!
}

type UnpinMessageResponse {
    messageId: UUID!
}

type UpdateAvatarResponse {
    file: String!
}

type UpdateBioResponse {
    id: UUID!
}

type UpdateChannelBannerResponse {
    id: UUID!
}

type UpdateChatSettingsResponse {
    id: UUID!
}

type UpdateOfflineBannerResponse {
    id: UUID!
}

type UpdateProfileResponse {
    id: UUID!
}

type UpdateStreamSettingsResponse {
    id: UUID!
}

type UploadFileResponse {
    fileName: String!
}

type VodDto {
    createdAt: DateTime!
    description: String
    duration: Long!
    id: UUID!
    preview: String
    source: String
    streamer: StreamerDto
    streamerId: String!
    title: String
    views: Long!
}

"A connection to a list of items."
type VodsConnection {
    "A list of edges."
    edges: [VodsEdge!]
    "A flattened list of the nodes."
    nodes: [VodDto!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type VodsEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: VodDto!
}

"Defines when a policy shall be executed."
enum ApplyPolicy {
    "After the resolver was executed."
    AFTER_RESOLVER
    "Before the resolver was executed."
    BEFORE_RESOLVER
    "The policy is applied in the validation step before the execution."
    VALIDATION
}

enum ChatMessageType {
    USER_MESSAGE
}

enum RoleType {
    ADMINISTRATOR
    BROADCASTER
}

enum SortEnumType {
    ASC
    DESC
}

enum StreamSourceType {
    HLS
    WEB_RTC
}

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

scalar UUID

"The `Upload` scalar type represents a file upload."
scalar Upload

input BooleanOperationFilterInput {
    eq: Boolean
    neq: Boolean
}

input ChatMessageDtoFilterInput {
    and: [ChatMessageDtoFilterInput!]
    createdAt: DateTimeOperationFilterInput
    id: UuidOperationFilterInput
    isActive: BooleanOperationFilterInput
    isDeleted: BooleanOperationFilterInput
    message: StringOperationFilterInput
    or: [ChatMessageDtoFilterInput!]
    replyId: UuidOperationFilterInput
    senderId: StringOperationFilterInput
    type: ChatMessageTypeOperationFilterInput
}

input ChatMessageDtoSortInput {
    createdAt: SortEnumType
    id: SortEnumType
    isActive: SortEnumType
    isDeleted: SortEnumType
    message: SortEnumType
    replyId: SortEnumType
    senderId: SortEnumType
    type: SortEnumType
}

input ChatMessageTypeOperationFilterInput {
    eq: ChatMessageType
    in: [ChatMessageType!]
    neq: ChatMessageType
    nin: [ChatMessageType!]
}

input CreateMessageInput {
    chatId: UUID!
    message: String!
    replyMessageId: UUID
}

input CreateRoleInput {
    roleType: RoleType!
    streamerId: String!
}

input DateTimeOperationFilterInput {
    eq: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime]
    lt: DateTime
    lte: DateTime
    neq: DateTime
    ngt: DateTime
    ngte: DateTime
    nin: [DateTime]
    nlt: DateTime
    nlte: DateTime
}

input DeleteMessageInput {
    messageId: UUID!
}

input FinishAuthInput {
    userName: String!
}

input FollowInput {
    streamerId: String!
}

input LongOperationFilterInput {
    eq: Long
    gt: Long
    gte: Long
    in: [Long]
    lt: Long
    lte: Long
    neq: Long
    ngt: Long
    ngte: Long
    nin: [Long]
    nlt: Long
    nlte: Long
}

input PinMessageInput {
    messageId: UUID!
}

input RemoveRoleInput {
    roleId: UUID!
}

input RoleDtoFilterInput {
    and: [RoleDtoFilterInput!]
    broadcasterId: StringOperationFilterInput
    id: UuidOperationFilterInput
    or: [RoleDtoFilterInput!]
    streamerId: StringOperationFilterInput
    type: RoleTypeOperationFilterInput
}

input RoleDtoSortInput {
    broadcasterId: SortEnumType
    id: SortEnumType
    streamerId: SortEnumType
    type: SortEnumType
}

input RoleTypeOperationFilterInput {
    eq: RoleType
    in: [RoleType!]
    neq: RoleType
    nin: [RoleType!]
}

input StringOperationFilterInput {
    and: [StringOperationFilterInput!]
    contains: String
    endsWith: String
    eq: String
    in: [String]
    ncontains: String
    nendsWith: String
    neq: String
    nin: [String]
    nstartsWith: String
    or: [StringOperationFilterInput!]
    startsWith: String
}

input UnfollowInput {
    streamerId: String!
}

input UnpinMessageInput {
    chatId: UUID!
}

input UpdateAvatarInput {
    file: String!
}

input UpdateBioInput {
    bio: String!
}

input UpdateChannelBannerInput {
    channelBanner: String!
}

input UpdateChatSettingsInput {
    bannedWords: [String!]!
    followersOnly: Boolean!
    id: UUID!
    slowMode: Int
    subscribersOnly: Boolean!
}

input UpdateOfflineBannerInput {
    offlineBanner: String!
}

input UpdateProfileInput {
    discord: String
    instagram: String
    youtube: String
}

input UploadFileInput {
    file: Upload!
}

input UuidOperationFilterInput {
    eq: UUID
    gt: UUID
    gte: UUID
    in: [UUID]
    lt: UUID
    lte: UUID
    neq: UUID
    ngt: UUID
    ngte: UUID
    nin: [UUID]
    nlt: UUID
    nlte: UUID
}

input VodDtoFilterInput {
    and: [VodDtoFilterInput!]
    createdAt: DateTimeOperationFilterInput
    description: StringOperationFilterInput
    duration: LongOperationFilterInput
    id: UuidOperationFilterInput
    or: [VodDtoFilterInput!]
    preview: StringOperationFilterInput
    source: StringOperationFilterInput
    streamerId: StringOperationFilterInput
    title: StringOperationFilterInput
    views: LongOperationFilterInput
}

input VodDtoSortInput {
    createdAt: SortEnumType
    description: SortEnumType
    duration: SortEnumType
    id: SortEnumType
    preview: SortEnumType
    source: SortEnumType
    streamerId: SortEnumType
    title: SortEnumType
    views: SortEnumType
}
